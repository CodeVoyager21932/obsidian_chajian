
---

## 1. 总体目标 & 约束（融合增强版）

### 1.1 目标（不变）

在 Obsidian 里构建一套「职业规划操作系统」，打通：

- 自我画像：你多年的 Obsidian 笔记（课程 / 项目 / 日记 / 反思）
- 市场画像：招聘 JD / 面经 / 行业趋势

自动输出：

- 我的能力画像（会什么、做到什么程度、有哪种性格/偏好）
- 市场对目标岗位的共识要求
- 两者的差距分析（缺什么、哪些是优势）
- 在真实时间约束下可落地的行动计划（学习 / 项目 / 习惯）

### 1.2 关键约束 / 原则

#### 本地私用插件

- 插件不开放给他人使用，不上架，不开源。
- 所有逻辑优先在 Obsidian 插件（TypeScript）内部实现，避免 Python + TS 双栈维护。
- Python 脚本仅作为「可选批处理工具」（如果真的需要高性能冷启动）。

#### 隐私优先（强化版）

- 所有原始笔记 & 画像数据只存本地。
- 支持配置本地 LLM（Ollama / LM Studio）Base URL，NoteCard / JDCard 抽取阶段可完全离线。
- 对外网 LLM 调用，在设置中明显标识「会将内容发送到外部 API」。
- 对反思/日记类笔记，在发送给外部 LLM 前，经过本地 `PrivacyGuard` 做 **PII 过滤**（手机号、邮箱、特定人名等正则脱敏），减少隐私泄露风险。
- 支持在设置中 **排除某些目录或标签** 不参与任何 LLM 调用。

#### 性能、稳定性与可维护性（强化版）

- Vault 可能很大：采用「冷启动全量索引 + 增量更新 + 异步队列 + 进度条」。
- 队列具备：
    - 最大并发数（1–3，可配置）
    - 简单的节流 / 限流（如每分钟最大请求数，或「慢/中/快」预设）
    - 暂停 / 恢复 / 取消 操作
- 所有 LLM 输出必须通过 Zod（或 ajv）进行 JSON Schema 校验，不合格自动重试，最多 N 次（可配置）。
- 在 `llmClient` 内部提供通用 **JSON 清洗器**：
    - 自动剥离多余文本 / Markdown，只保留首尾成对的 `{}` / `[]` 尝试 `JSON.parse`
    - 清洗失败才计入一次真正的「重试」
- 索引文件采取「分散存储 + 聚合视图」策略，降低单点故障。
- 所有 JSON 文件（NoteCard / JDCard / Profile / Plan）增加 `schema_version`，并在读写时由 `IndexStore` 负责 **版本迁移/升级**。
- 所有写 `.json` 的操作统一通过 `FileService`（带简单锁与备份）完成，避免并发写入损坏文件。
- 当 LLM 解析多次失败或文件被判定为损坏时：
    - 记录到插件目录下的 `error_log.md`
    - 不让插件崩溃或静默失败，在 UI 提示「有若干条索引失败」。

#### 多模型 & 成本控制（强化版）

- NoteCard / JDCard 抽取：选用便宜模型（GPT-4o-mini / Gemini Flash / 本地模型）。
- 差距分析 & 计划生成：选用逻辑强的模型（Claude 3.5 Sonnet / GPT-4o）。
- 明确提示：结构化抽取使用廉价模型，分析规划使用昂贵模型。
- 控制上下文窗口和 token 成本：
    - ProfileEngine 生成 **压缩版画像视图**（只保留 Top N 技能、最近 M 个项目、必要聚合信息）
    - StrategyCore 做差距分析时，仅发送压缩视图 + 目标岗位相关的少量上下文，而不是整个 Vault 的全量画像。

#### 语义标准化与演进策略

- 引入技能名称归一化层（Taxonomy）：
    - 通过 `data/taxonomy.json` 或 Settings 中维护「技能别名表」，统一将 "Python3" / "python" / "Python scripting" 映射为标准名 "Python"。
    - 后续可选：使用 Embedding 辅助判断近义技能是否同一类。
- 时间衰减：
    - MVP 阶段采用简单的 **阶梯式衰减规则**，后续再细化。
- 演进策略：
    - 先完成 MVP 闭环（Phase 0–4）：
        - 少量笔记 → NoteCard → 简单 self_profile（含技能权重、偏好、项目）
        - 少量 JD → JDCard → 简单 market_profile
        - 手动触发一次差距分析 & 行动计划
    - 后续增强（Phase 5 及以后）：
        - TaskBridge：任务下发 & 反馈回流
        - 时间衰减精细化（按技能类别）
        - Embedding + RAG 检索增强
        - 更智能的任务 → 技能经验映射

> 说明：Phase 0–4 是 **MVP 范围**；Phase 5 属于增强功能，可以后置实现。

---

## 2. 系统总览（融合增强版）

### 2.1 三层数据结构（逻辑层不变，物理存储增强）

逻辑三层：Raw → Card → Profile / View。

#### Raw 层（原始层）

- Obsidian 原始笔记：
    - `01_Self/`：项目、课程、日记、反思等
    - `02_Market/`：JD / 面经汇总
- 原始 MD 文件只读，或仅在 frontmatter 增加标签等非破坏性信息。

#### Card 层（卡片层）

- 每个有意义的单位抽象成一张卡片：
    - NoteCard：一篇项目/课程/反思 → 1 卡（多维信息）
    - JDCard：一篇 md 中多个 JD → N 张卡
- 物理存储（增强版）：
    - 定义 `getCardPath(notePath: string): string` 等工具函数，屏蔽具体路径规则，方便未来迁移。
    - 方案 A（推荐，默认）：
        - 在插件数据目录下维护与原始路径同构的结构，例如：
            - 原文档：`01_Self/Projects/campus_delivery.md`
            - 卡片：`.career_os/cards/01_Self/Projects/campus_delivery.card.json`
    - 方案 B（可选配置）：
        - 将卡片直接放在原 md 同级目录下的隐藏子目录，如：
            - `01_Self/Projects/.career_cards/campus_delivery.card.json`
- 所有 Card 文件均：
    - 含 `schema_version`
    - 写入前自动备份为 `.bak`（仅最新一份或 N 份）

#### Profile / View 层（画像 / 视图层）

- self_profile：聚合所有 NoteCard 的自我画像（含时间权重）
- market_profile：聚合 JDCard 的市场画像（按岗位/城市/薪资）
- gap_analysis：self vs market 的对比结果
- plans：基于差距和时间约束生成的行动计划（Markdown）
- 视图类型：
    - 普通画像视图（Detail View）：尽量完整保留信息
    - **压缩画像视图（Analysis View）**：仅保留用于 LLM 分析的关键信息：
        - Top N 技能（按权重）
        - 最近 M 个项目
        - 高频偏好/特质
- 未来扩展：
    - RAG 视图：基于 Embedding 的「与当前 JD 最相关的 K 个 NoteCard」列表，作为差距分析的补充上下文。

### 2.2 组件架构（TypeScript 全栈 + 校验 + 队列）

单一 Obsidian 插件：`CareerOS`

text

```
main.ts                    # 插件入口，注册命令、视图、事件监听
manifest.json              # 插件描述
styles.css                 # 可选，UI 样式

types.ts                   # 所有核心数据结构 TypeScript 接口定义
schema.ts                  # Zod/AJV Schema 校验（NoteCard/JDCard/Profile）

modules/
  ProfileEngine.ts         # 自我画像索引 & 更新（NoteCard + self_profile）
  MarketScanner.ts         # 市场画像（JDCard + market_profile）
  StrategyCore.ts          # 差距分析 & 行动计划生成
  TaskBridge.ts            # 计划 → 每日/每周任务 & 完成反馈（增强阶段）
  Taxonomy.ts              # 技能别名表 & 归一化逻辑
  PrivacyGuard.ts          # PII 过滤、敏感内容脱敏（仅对外部 LLM 生效）
  IndexStore.ts            # 统一管理索引读写 & 版本迁移 & 备份
  RagEngine.ts             # （可选）Embedding + 检索增强，用于后期加强 Gap 分析

views/
  DashboardView.tsx        # React 总览面板（使用 Context 管理状态）
  SettingsTab.ts           # API Key & 模型路由 & Prompt 模板 & Proxy 配置

utils/
  llmClient.ts             # 多 API / 多模型统一调用 + 重试 + JSON 清洗
  hash.ts                  # Hash 计算（内容、JD 文本等）
  fs.ts / FileService.ts   # 文件读写 & 原子写入封装 Obsidian API
  queue.ts                 # 异步任务队列（冷启动/批处理）+ 限流 + 进度条
  time.ts                  # 时间权重、日期解析等工具
  embedding.ts             # （可选）Embedding 封装，用于语义匹配/RAG
  logger.ts                # 日志记录 & error_log 写入

prompts/
  noteCardPrompt.txt       # PROMPT 1
  jdCardPrompt.txt         # PROMPT 2
  planPrompt.txt           # PROMPT 3
```

改进点（总结）：

- `types.ts` 统一接口定义，所有模块 & UI 严格类型检查。
- `schema.ts` 使用 Zod 定义与 LLM 输出 1:1 对应的 Schema，支持 `schema_version` 校验和旧版迁移。
- `queue.ts` 统一管理所有 LLM 调用任务，支持并发控制、节流、暂停/恢复，共享进度 UI。
- `llmClient.ts` 内部集成 JSON 清洗 + 错误分类（Schema 错误 vs 其他错误）。
- Prompt 集中在 `prompts/` 目录，不在业务代码中散落硬编码字符串。

---

## 3. 数据结构设计（融合增强版）

### 3.1 NoteCard（自我笔记卡）

TypeScript 接口（增强版示例）：

TypeScript

```
export type NoteType = "project" | "course" | "reflection" | "other";

export interface TechItem {
  name: string;            // 原始技术名，如 "python3", "Postgres"
  context: string;         // 使用场景
  level: "入门" | "熟悉" | "熟练" | "精通";
}

export interface Preferences {
  likes: string[];
  dislikes: string[];
  traits: string[];
}

export interface NoteCard {
  schema_version: number;  // 例如 1

  note_path: string;       // 笔记相对路径（唯一标识）
  hash: string;            // 笔记内容 hash，用于变更检测

  summary: string;
  type: NoteType;
  time_span: string;

  tech_stack: TechItem[];
  topics: string[];
  preferences: Preferences;
  evidence: string[];

  last_updated: string;    // 从文本/文件时间推断：yyyy-MM-dd 或 ""（详见时间解析策略）
  detected_date?: string;  // 本次抽取的日期（系统生成 ISO 字符串）

  status?: "draft" | "confirmed"; // 是否已人工审核
  deleted?: boolean;       // 逻辑删除标记（文件删除时置 true）

  // 可选增强字段（MVP 可不实现或仅预留）：
  embedding_id?: string;   // 对应 embedding 索引中的 ID（而非直接存向量）
}
```

**时间解析优先级建议：**

1. 文本中提到的日期 / 学期；
2. 文件名中的日期（如 `2024-01-xx_xxx.md`）；
3. 文件创建时间；
4. 文件最后修改时间。

**偏好提取策略（同前，强调）：**

- 仅对 `type = "reflection"` 或带特定 tag（如 `#journal`）的笔记重点提取 `preferences`。
- 对纯技术项目笔记，偏好字段可以为空数组或仅提炼非常明确的表述。

**技能归一化（不在 NoteCard 层做）：**

- NoteCard 存原始 `tech_stack.name`；
- 在 ProfileEngine 中通过 `Taxonomy` 归一化为标准技能名，汇总到 SelfProfile。

### 3.2 JDCard（一篇 md 中的多个 JD）

TypeScript 接口（增强版示例）：

TypeScript

```
export interface JDCard {
  schema_version: number;  // 例如 1

  jd_id: string;           // 唯一 ID（UUID）
  source_note: string;     // 对应的 JD 汇总 md 文件路径

  company: string;
  title: string;
  location: string;
  salary_range: string;

  skills_required: string[];
  skills_optional: string[];
  experience: string;
  degree: string;

  raw_text_hash: string;   // 用于去重
  tags: string[];

  created_at: string;      // 初次抽取时间
  updated_at: string;      // 最近一次更新（文本变化或字段纠正）
  deleted?: boolean;       // 逻辑删除标记（JD 被删或失效时可设置）
}
```

- 所有 JDCard 存在 `data/market_cards/` 目录（或 `.career_os/market_cards/`），一条 JD 一文件或分桶（按 role/location）均可。
- `jd_id` 与 `raw_text_hash` 组合，用于判断是「更新」还是「新增」。

### 3.3 SelfProfile / MarketProfile / Plan

#### SelfProfile（自我画像）

TypeScript

```
export type SkillCategory =
  | "language"
  | "framework"
  | "database"
  | "tool"
  | "platform"
  | "soft";

export interface SkillProfile {
  name: string;            // 归一化后的标准技能名，如 "Python"
  category?: SkillCategory;
  level: number;           // 0-5 浮点，综合多个 NoteCard + 时间权重 + 经验值
  evidence_notes: string[]; // 相关 NoteCard 的路径列表（或 ID）
  last_active: string;     // 最近一次与该技能相关的活动时间
}

export interface SelfProfile {
  schema_version: number;  // 例如 1

  skills: SkillProfile[];
  preferences: Preferences;
  projects: Array<Pick<NoteCard, "note_path" | "summary" | "tech_stack" | "time_span">>;

  // 可选：用于 LLM 分析的压缩视图（减少 token）
  analysis_view?: {
    top_skills: SkillProfile[];       // Top N
    recent_projects: Array<Pick<NoteCard, "note_path" | "summary" | "tech_stack" | "time_span">>; // 最近 M
  };

  last_built: string;     // 最近一次重建 SelfProfile 的时间
}
```

**评分规则（建议）：**

1. 对每个 NoteCard 的 `tech_stack` 项，按 `type` 赋权：
    
    - project：权重 1.0
    - course：权重 0.7
    - reflection/other：权重 0.3
2. level 映射为数值：
    
    - 入门：1
    - 熟悉：2
    - 熟练：3
    - 精通：4
3. 时间权重（MVP 采用阶梯规则）：
    
    TypeScript
    
    ```
    // monthsAgo = 当前时间距离 last_updated 的月份数
    function timeWeight(monthsAgo: number): number {
      if (monthsAgo <= 6) return 1.0;
      if (monthsAgo <= 24) return 0.7;
      return 0.4;
    }
    ```
    
4. 计算单条技能贡献：
    
    TypeScript
    
    ```
    score = levelValue * weightByType * timeWeight(monthsAgo);
    ```
    
5. 对同一标准技能名（归一化后）累积 `score`，映射/归一化到 0–5。
    

后续可以在 `SkillCategory` 维度上使用不同的衰减策略（非 MVP 必需）。

#### MarketProfile（市场画像）

TypeScript

```
export interface SkillDemand {
  name: string;                   // 经 Taxonomy 归一化后的技能名
  frequency: number;              // 出现次数或占比
  experience_hint?: string[];     // JD 中提到的典型经验描述
}

export interface MarketProfile {
  schema_version: number;         // 例如 1

  role: string;
  location: string;
  skills_demand: SkillDemand[];
  soft_requirements: string[];
  experience_distribution: Record<string, number>;
  sample_jd_ids: string[];
  last_built: string;
}
```

#### Plan（行动计划）

- 仍旧是 Markdown 文件，但在生成时添加 frontmatter：

Markdown

```
---
role: "Python 后端（杭州）"
period: "3 个月"
weekly_hours: 10
generated_at: "2024-12-07"
source_self_profile: "self_profile_2024-12-07.json"
source_market_profile: "market_python_backend_hz_2024-12-07.json"
---

# 针对“Python 后端（杭州）”的 3 个月行动计划
...
```

- 为配合 TaskBridge 回流，可在正文任务中（增强阶段）埋入隐式 skill 关联，如：

Markdown

```
- [ ] [skill:Python] 完成 XX 课程的基础部分并做 3 条笔记
- [ ] [skill:Redis] 在现有项目中为接口 A 加上 Redis 缓存
```

或增强为在 Plan frontmatter 中增加任务 → 技能映射结构（非 MVP 强制）。

---

## 4. 核心流程设计（融合增强版）

### 4.1 冷启动：构建 NoteCard 索引（插件内部 + 队列）

插件提供命令：

- 「CareerOS: 全量索引自我笔记 (冷启动)」

功能：

1. 用户在设置中选择索引范围：
    - `01_Self/Projects/`
    - `01_Self/Courses/`
    - `01_Self/Reflections/`（可选）
2. 扫描选定目录，获取所有 md 文件路径。
3. 对每个文件：
    - 读取内容，计算 `hash`。
    - 检查是否已有对应 `.card.json` 且 `hash` 相同：
        - 相同 → 跳过。
        - 不同或不存在 → 加入「待提炼队列」。
4. 队列 `queue.ts` 管理异步任务：
    - 控制最大并发数（1–3，可配置）。
    - 简单节流：避免在短时间内触发大量 LLM 请求，减少被限流风险。
    - 支持「暂停」「继续」「取消」。
5. 对每个队列任务：
    - 通过 `PrivacyGuard` 对内容做 PII 过滤（仅当目标模型为外部 LLM 时）。
    - 使用 PROMPT 1 调用 `llmClient`：
        - 启用 JSON 模式（provider 支持情况下）。
        - 返回后经过内置 JSON 清洗器 → `JSON.parse`。
        - 使用 Zod Schema 校验。
    - 构造 NoteCard 对象：
        - `note_path`、`hash`、`schema_version` 由程序填充。
        - `detected_date` 填当前日期。
    - 成功 → 使用 `FileService` 原子写入 `.card.json`，并备份旧版本。
    - 失败（解析/校验）：
        - 短暂延时后重试，最多 N 次（可配置）。
        - 若仍失败 → 在 `error_log.md` 记录该文件路径 & 错误信息，在 UI 中计数展示。

**冷启动 dry-run 选项（建议在设置中提供）：**

- 只处理前 N 条笔记，将抽取结果打印到开发者控制台或临时预览视图，不写入文件。
- 用户确认抽取质量后，再执行正式全量索引。

### 4.2 增量更新：新建/修改/重命名/删除

插件监听 Obsidian 事件：

#### file-save

- 若文件在监控目录（`01_Self/*`）：
    - 读取内容计算 `hash`。
    - 若对应 `.card.json`：
        - 解析并通过 Schema 校验（如失败，可触发重建该卡片）。
        - 比较 `hash`：
            - 相同 → 不处理。
            - 不同 → 将该文件加入 LLM 队列进行更新（同冷启动流程）。
    - 若未找到 `.card.json`：
        - 视为新建，加入队列抽取。

#### rename / move

- 使用 Obsidian 的 `rename`/`move` 事件：
    - 更新对应 NoteCard 的 `note_path`。
    - 通过 `getCardPath` 重新计算卡片路径，移动 `.card.json` 文件。
- 为避免频繁 rename / save 引起抖动：
    - 可以对重建 Profile 操作做 300–500ms 的 **防抖**，合并短时间内的多次改动。

#### delete

- 逻辑删除策略：
    - 不立即删除 `.card.json` 文件；
    - 将 NoteCard 的 `deleted` 字段置为 `true`；
    - Profile 聚合时自动过滤 `deleted = true`。
- 可在 Dashboard 提供「已删除卡片」视图，支持：
    - 恢复（清除 `deleted` 标记）
    - 物理删除（清理对应 card 文件）

#### 多设备同步 / 冲突处理

- 读取 `.card.json` 时：
    - 必须 `JSON.parse` + Zod 校验；
    - 若解析失败或 Schema 不通过：
        - 视为损坏，尝试：
            - 重新对对应 md 文件触发一次抽取；
            - 将旧 `.card.json` 备份并覆盖；
            - 记录到 `error_log.md`。

### 4.3 JD 处理：一篇 md 拆出多个 JDCard

命令：

- 「CareerOS: 为当前笔记抽取 JDCard」

流程：

1. 当用户在 `02_Market/` 中打开某篇 JD 汇总 md 时，执行命令。
2. 读取整篇内容。
3. 使用 PROMPT 2 调用 LLM，返回 JDCard 数组：
    - 同样应用 JSON 清洗 + Zod 校验。
4. 对每个 JD 元素：
    - 计算 `raw_text_hash`。
    - 查询是否已有相同 `raw_text_hash` 的 JDCard：
        - 有 → 视为更新：保留原 `jd_id`，更新内容与 `updated_at`。
        - 无 → 创建新 JDCard，生成 `jd_id`、`created_at`。
5. 写入 `data/market_cards/` 下的独立文件。
6. 更新或延迟重建 `market_index.json` / 若干 MarketProfile 缓存。

### 4.4 自我画像 & 市场画像构建（带时间权重 + 技能归一化）

#### 自我画像（SelfProfile）

- 由 `ProfileEngine` 负责：
    1. 读取所有 NoteCard，过滤：
        - `deleted = true` 的忽略；
        - 可选：仅统计 `status = "confirmed"` 或给其更高权重。
    2. 技能归一化：
        - 调用 `Taxonomy`，将原始 `tech_stack.name` 映射为标准技能名；
        - 对无法匹配的技能，可以：
            - 抛回原始名；
            - 或放入「未归一」集合，供 UI 提示人工处理。
    3. 按前述规则计算技能分数与时间权重。
    4. 聚合偏好：
        - 主要从 `type = "reflection"` 且非 deleted 的 NoteCard 提取；
        - 按出现次数排序，保留 Top N。
    5. 聚合项目：
        - 从 `type = "project"` 的 NoteCard 中提取基础信息。
    6. 生成 SelfProfile：
        - 完整视图；
        - 附带 `analysis_view`（Top N 技能 + 最近 M 个项目）。
    7. 使用 `FileService` 写入 `self_profile.json` 和可读版 `self_profile.md`（放在 `03_Mapping/`）。

#### 市场画像（MarketProfile）

- 由 `MarketScanner` 负责：
    1. 从 JDCard 中按 role/location 过滤出特定岗位集合。
    2. 统计技能频率：
        - 对 `skills_required` 与 `skills_optional` 均可做归一化（Taxonomy）。
        - 算出出现次数 & 占比。
    3. 经验 / 学历分布简单统计。
    4. 保存代表性 `sample_jd_ids` 若干。
    5. 写入 `market_profile_{role}_{loc}.json` + `.md`。

### 4.5 差距分析 & 计划生成（策略核心 + 上下文控制）

`StrategyCore` 的输入：

- `self_profile`（含 `analysis_view`）
- `market_profile`
- 用户 UI 选择：
    - 目标岗位（role + location）
    - 周可用时间（小时数）
    - 规划周期（如 3 个月）

**上下文控制与压缩：**

- 传给 LLM 的 SelfProfile 内容：
    - 优先使用 `analysis_view`（Top N 技能 + 最近 M 项目）。
    - 对偏好 / 软技能仅传高频项。
- 传给 LLM 的 MarketProfile：
    - 列出 Top N 需求技能及其频率；
    - 典型经验 / 学历分布简要统计。
- 如后期接入 RAG：
    - 使用 Embedding 为目标岗位的关键技能或 JD 文本向量化；
    - 从 NoteCard 集合中检索出与目标最相关的 K 条；
    - 将这些 NoteCard 的摘要作为附加上下文发送给 LLM。

**流程：**

1. UI 中选择目标 role/location、周期、每周时间。
2. `StrategyCore` 构造 Prompt 变量（见 PROMPT 3）。
3. 调用高质量 LLM（Claude Sonnet / GPT-4o）：
    - 不必强制 JSON；输出 Markdown 报告。
4. 保存至 `03_Mapping/Plan_{role}_{location}_{date}.md`。
5. 在 Dashboard 中：
    - 显示最近生成的 Plan 列表；
    - 提供「设为当前激活计划」按钮；
    - 概要展示该 Plan 的：
        - 技术匹配度 / 短板总览；
        - 预计每周任务量是否符合约束。

### 4.6 任务下发 & 完成反馈（TaskBridge，增强阶段）

> 说明：Phase 5，为增强功能，不必纳入最初 MVP。

#### 任务下发

- 从当前激活 Plan 中解析 Markdown 任务：
    
    Markdown
    
    ```
    - [ ] ...   // 任务条目
    ```
    
- 对于具有显式技能标记（如 `[skill:Python]`）的任务，记录技能关联。
    
- 支持命令：
    
    - 「CareerOS: 将当前 Plan 的本周任务同步到今日 Daily Note」
- 注入方式：
    
    - 在当日 Daily Note 中插入一个标题块（如 `## CareerOS 本周任务`），下挂任务列表；
    - 或生成符合 Tasks 插件格式的待办（如加特定 tag）。

#### 完成反馈（两阶段设计）

- **MVP 做法（简单版）：**
    - 若任务标题中包含某个标准技能名（来自 Taxonomy），则在 ProfileEngine 内部为该技能增加少量经验值加成。
- **增强做法（推荐）：**
    - 在 Plan 生成时：
        - 让 LLM 在任务后加上轻量技能标记（如 `[skill:Python,Redis]`）或在 Plan frontmatter 定义。
    - 回流时：
        - 监听任务勾选事件（监视当日 Daily Note / Tasks 插件）；
        - 根据技能标记直接更新某个 `practice_experience` 累积表；
        - 下次重建 SelfProfile 时，将该经验加成融合到技能得分中。
    - 进一步增强（可选）：
        - 使用廉价模型（extract 角色）对已完成任务文本进行简要分类，判断其主要提升了哪些技能。

---

## 5. 多 API / 多模型策略（融合增强版）

### 5.1 llmClient 设计原则

TypeScript

```
export type ModelRole = "extract" | "analyze" | "embedding";

export interface LLMConfig {
  provider: "openai" | "anthropic" | "local" | "google";
  baseUrl?: string;              // 支持自定义（本地 LLM）
  apiKey?: string;
  model: string;
  jsonMode?: boolean;            // 对 extract 类任务尽量开启 JSON 模式
  maxRetries?: number;           // 针对当前角色的默认重试次数
}

export async function callLLM(
  role: ModelRole,
  prompt: string,
  options?: {
    maxRetries?: number;
    expectJson?: boolean;
  }
): Promise<string> {
  // 选择对应的模型配置
  // JSON 输出时使用内置 JSON 清洗器
  // 按指数退避重试，记录错误到 logger/error_log
}
```

SettingsTab 中提供：

- 不同角色（extract / analyze / embedding）的独立模型配置。
- Proxy / Base URL 配置（支持本地 LLM）。
- 全局重试次数 / 超时时间 / 并发 & 限流策略（交给 queue.ts 控制）。

### 5.2 任务与模型的映射

- 长文提炼 / NoteCard 构建（冷启动 & 增量）：
    - 角色：`extract`
    - 模型：GPT-4o-mini / Gemini Flash / Claude Haiku / 本地模型
    - 要求：
        - 尽量启用 JSON 模式。
        - 使用 PROMPT 1。
        - 输出经 JSON 清洗 + Schema 校验 + 重试。
- JD 列表提取 & JSON 结构化：
    - 角色：`extract`
    - 模型同上。
    - 使用 PROMPT 2。
- 差距分析 & 行动计划生成：
    - 角色：`analyze`
    - 模型：Claude 3.5 Sonnet / GPT-4o 等高质量模型。
    - 使用 PROMPT 3。
    - 上下文为 `analysis_view` + MarketProfile 摘要。
- Embedding（可选）：
    - 角色：`embedding`
    - 模型：OpenAI / 本地 embedding 模型。
    - 用途：
        - NoteCard summary / 技能名 / JD 要求向量化；
        - 加强技能归一、RAG 检索与岗位匹配。

> 对本地模型：如其 JSON 输出不稳定，可使用更简单 Prompt 或 Grammar/BNF 约束输出。

---

## 6. 实施阶段建议（融合增强版）

> 保持 Phase 0–5 的结构，明确 MVP 范围 & 增强点。  
> 对 Kiro：从 Phase 1 开始实现，Phase 0 仅需手动在聊天模型里跑几次 Prompt。

### Phase 0：手动验证 Prompt（不写代码）

- 从 `01_Self/` 选 3 篇项目笔记 + 2 篇反思/日记。
- 从 `02_Market/` 选 2–3 条 JD。
- 在 ChatGPT / Claude 里用 PROMPT 1/2/3 试跑几次：
    - 调整字段名、枚举值，直到 JSON 结构稳定可用。
    - 观察：
        - 技能抽取是否合理；
        - 偏好是否不过度想象；
        - 差距分析是否贴近实际。
- 目标：
    - 确定 Prompt 模板基本可用；
    - 在 `schema.ts` 中写出对应的 Zod Schema（带 `schema_version`）；
    - 粗略确认生成的内容长度不会轻易超出目标模型的 context window。

### Phase 1：插件骨架 + 类型定义 + LLM Client

**目标**：插件能加载，能在设置中配置 API，能调用 LLM 返回一段固定文本，并完成基础类型/Schema 定义。

实现要点：

1. 创建基础插件结构：
    - `manifest.json`, `main.ts`, `SettingsTab.ts`。
2. 在 `types.ts` 中定义：
    - `NoteCard`, `JDCard`, `SelfProfile`, `MarketProfile`, `SkillProfile` 等接口，带 `schema_version`。
3. 在 `schema.ts` 中：
    - 使用 Zod 定义 NoteCard / JDCard / Profile Schema。
    - 预留版本迁移函数（例如 `upgradeNoteCardV1toV2` 等）。
4. 在 `utils/llmClient.ts` 中：
    - 封装基础 LLM 调用逻辑；
    - 支持可选 `jsonMode`；
    - 实现简单 JSON 清洗器（剥离 Markdown 包裹、截取首尾 `{}` / `[]`）。
5. 在 `prompts/` 目录下存放初版 PROMPT 1/2/3 文本，通过统一 `PromptStore` 加载。
6. 提供一个测试命令：
    - 「CareerOS: 测试调用 LLM」，调用指定模型，显示返回结果在控制台。

### Phase 2：ProfileEngine – 冷启动 & 增量（自我画像）

**目标**：实现 NoteCard 的生成与更新，不必马上做 UI，只需命令 + 日志。

实现要点：

1. `FileService` / `fs.ts`：
    - 封装 Obsidian 文件读写；
    - 实现原子写入：写到临时文件后再 rename；
    - 写前备份旧文件为 `.bak`。
2. `.card.json` 读写 & 路径计算（`IndexStore` + `getCardPath`）：
    - 给定 md 路径，找到/创建对应 card 文件路径；
    - 读写 JSON 时都通过 Schema 校验；
    - 不合法时触发重建或写入 `error_log`。
3. 冷启动命令：
    - 「CareerOS: 全量索引自我笔记」：
        - 扫描 `01_Self/` 目录 → 构建任务队列；
        - 调用 LLM + Schema 校验 → 写入 NoteCard；
        - 设置中可选「dry-run only」模式。
4. 增量更新：
    - 监听 `file-save`、`rename`、`delete` 事件；
    - 实现上述逻辑删除 / 更新路径 / 重建索引策略；
    - 通过 `queue.ts` 统一管理增量任务。
5. 初版 SelfProfile 构建：
    - 在 `ProfileEngine` 中实现简单聚合函数：
        - 技能加权 + 时间阶梯权重；
        - 偏好 Top N；
        - 项目列表；
    - 生成 `self_profile.json` + 可读版 `self_profile.md`，存放在 `03_Mapping/`。

### Phase 3：DashboardView – 基本自我画像 UI

**目标**：在 Obsidian 中看到基本自我画像界面，具备「一条主路径」与简单编辑能力。

实现要点：

1. 使用 React + Context 实现 `DashboardView.tsx`：
    - 创建一个简单的 `DashboardContext` 管理：
        - 当前 SelfProfile；
        - 索引状态（已索引笔记数 / 总笔记数 / 错误数量）。
2. 展示内容：
    - Top N 技能列表（name + level + evidence count）；
    - 最近 N 个项目（来自 SelfProfile）；
    - 错误摘要（如有 `error_log` 记录，显示数量与查看按钮）。
3. 交互：
    - 「刷新画像」按钮：
        - 手动触发重建 SelfProfile（调用 ProfileEngine）。
    - 「一条主路径」的引导区块：
        1. 检查自我画像是否构建完毕；
        2. 引导「去 Market 目录抽取 JD」；
        3. 引导「选择目标岗位并生成行动计划」（Phase 4 完成后）。
4. 基础 NoteCard 审核/微调（可选但推荐）：
    - 提供简单列表，显示若干未确认的 NoteCard（`status = "draft"`）；
    - 允许在 UI 中：
        - 修改某个技能的 level；
        - 删除明显错误的技能或偏好；
        - 标记该卡为 `confirmed`，下次重建时不自动覆盖（或覆盖策略可配置）。

### Phase 4：MarketScanner & StrategyCore – 打通 JD → 分析 闭环

**目标**：完整跑通「JD → MarketProfile → 差距分析 → Plan（Markdown）」。

实现要点：

1. `MarketScanner`：
    - 命令：「为当前 JD 汇总笔记抽取 JDCard」；
    - 将当前 note 内容送入 LLM（PROMPT 2）→ 得到 JD 数组；
    - 写入/更新 JDCard 文件；
    - 提供一个命令或 UI 流程：
        - 指定 role / location 条件，生成对应 MarketProfile（JSON + MD）。
2. `StrategyCore`：
    - 命令：「基于当前 SelfProfile & 市场画像生成行动计划」；
    - UI 选择：
        - 目标岗位（可从已有 MarketProfile 列表中选）；
        - 地点、周期、每周时间；
    - 从 SelfProfile 中构造 `analysis_view`（Top N 技能 + 最近 M 项目）；
    - 调用高质量 LLM（PROMPT 3），生成 Markdown 计划；
    - 写入 `03_Mapping/`，并在 Dashboard 中展示最近 Plan 列表。
3. Dashboard 集成：
    - 在主视图中新增「目标岗位 & 计划」区域：
        - 显示已有 MarketProfile 列表；
        - 生成新 Plan 的入口；
        - 显示「当前激活 Plan」的摘要（匹配度、主要短板、周期等）。

> 可选增强（Phase 4.5）：引入简易 RAG  
> 使用 Embedding 为 JD 技能向量化，从 NoteCard 中检索出相关 K 条，作为差距分析的补充上下文（放入 PROMPT 3 之前）。

### Phase 5：TaskBridge – 任务下发 & 反馈回流（增强阶段）

**目标**：从 Plan 拆出本周 Todo，自动写入 Daily Note，并将勾选结果反馈到 SelfProfile。此阶段不属于最小可用闭环，可在 MVP 稳定后再做。

实现要点：

1. 任务提取：
    - 从 Plan Markdown 中解析 `- [ ] ...` 任务；
    - 简单规则筛选「本周任务」：
        - 例如以章节标题「第 1 周」「本周任务」为边界。
2. 注入 Daily Note：
    - 命令：「把当前 Plan 的本周任务写入今日 Daily Note」；
    - 在 Daily Note 中插入统一块（方便后续解析）。
3. 反馈回流（MVP 版）：
    - 监控任务复选框状态变更（如通过解析最新 Daily Note）；
    - 若任务标题包含某标准技能名，增加该技能少量经验值加成（存在 ProfileEngine 内部）。
4. 反馈回流（增强版，后续迭代）：
    - 优先使用 Plan 中显式 `[skill:xxx]` 标记；
    - 或在 TaskBridge 中调用廉价 LLM 判断任务提升了哪些技能；
    - 将结果写入某个 `practice_index.json`；
    - 重建 SelfProfile 时考虑该经验加成。

---

## 7. Prompt 模板（融合改进版）

> 所有 Prompt 存放于 `prompts/` 目录，由 `PromptStore` 加载。  
> 下面是逻辑结构与关键约束（文本可按需要微调）。

### PROMPT 1：从一篇自我笔记生成 NoteCard JSON

text

```
你是一个职业生涯分析助手，负责从一篇个人笔记中，提炼出对“能力画像”和“职业规划”有价值的信息。

下面是要求：

1. 你只允许根据这篇笔记本身的信息进行判断，不要加入你自己的猜测或常识补全。
2. 特别是 "preferences"（喜欢/讨厌/性格），只在文本有**非常明确**表述时才填入；否则对应字段返回空数组。
3. 对技能水平（level）判断要保守，宁可低估，不要夸大。
4. 输出必须是**严格的 JSON 对象**（不含多余文本、注释或 Markdown 包裹）。

现在给你一篇 Markdown 笔记的全文。请你输出一个 JSON 对象，严格符合下面的 schema（字段名和类型都要一致）：

{
  "note_path": "",              // 这里先留空字符串，由程序填入
  "hash": "",                   // 留空，由程序计算

  "summary": string,            // 用 2~4 句话描述这篇笔记主要在讲什么（偏事实）

  "type": string,               // 从 ["project","course","reflection","other"] 中选择一个最合适的

  "time_span": string,          // 若文中有提到起止时间，请提取；否则用 "" 空字符串

  "tech_stack": [
    {
      "name": string,           // 技术名，如 Python, MySQL, Redis
      "context": string,        // 它是怎么被用到的（一句话）
      "level": string           // 从 ["入门","熟悉","熟练","精通"] 中选择
    }
  ],

  "topics": [string],           // 这篇笔记涉及到的主题标签，如 ["后端开发","爬虫","学习方法"]

  "preferences": {
    "likes": [string],          // 只在文本中有明确“喜欢/享受/感兴趣”等字眼时才填写
    "dislikes": [string],       // 只在文本中有明确“讨厌/不喜欢/排斥”等字眼时才填写
    "traits": [string]          // 文本中明显体现的性格/工作风格，如 ["自我驱动","抗压","喜欢钻研"]
  },

  "evidence": [string],         // 这篇笔记中可以作为“我做过某件事”的证据句子，列出 2~5 条

  "last_updated": string        // 若文中能看出时间（如日期/学期），请提取；否则用 ""。
}

注意：
- 不要输出注释，只输出 JSON。
- 不要输出 Markdown 代码块标记 ``` 或其他任何说明文字。
- 如果某个字段无法从文本中推断，请用合理的空值（如 "" 或 []）。
- JSON 顶层必须是一个对象，不能包含额外文字。

下面是笔记全文：
{{这里粘贴一篇 md 内容}}
```

### PROMPT 2：从一篇 md 中拆出多个 JDCard（JSON 数组）

text

```
你是一个招聘信息抽取助手，负责从一篇 Markdown 文本中识别出“多条岗位信息”。

这篇文档中可能包含 N 条不同公司的 JD（招聘启事），它们通常以标题、分隔线或空行分隔。

请你阅读全文后，输出一个 **JSON 数组**，每个元素代表一条 JD。每条 JD 的字段如下：

{
  "company": string,            // 公司名称，如能从文本推断；否则用 ""。
  "title": string,              // 岗位名称，如“Python 后端开发工程师”
  "location": string,           // 工作城市，尽量从文本中提取；否则 ""。
  "salary_range": string,       // 如 "15-25k", 若没有则 ""。

  "skills_required": [string],  // 明确写在“岗位要求/任职要求”中的核心技能
  "skills_optional": [string],  // 加分项/优先项提到的技能

  "experience": string,         // 工作/项目经验要求原文，如 "1-3 年"，没有则 ""。
  "degree": string,             // 学历要求，如 "本科及以上"，没有则 ""。

  "raw_text_hash": ""           // 暂时用 ""，由程序计算
}

要求：
- 一定要输出 JSON 数组（用 [] 包裹），即使只有一条 JD 也要用数组形式。
- 不要照抄整段 JD 文本，只提取结构化信息。
- skills_required/skills_optional 中只放技能关键词（如 "Python","Django","MySQL"），不要放整句。
- 不要输出任何说明文字、注释或 Markdown 代码块标记。
- 只输出纯 JSON。

下面是包含多个 JD 的 Markdown 文本：
{{这里粘贴 JD 汇总 md}}
```

### PROMPT 3：差距分析 + 行动计划生成（Markdown 报告）

text

```
你是我的职业发展导师，现在有两份画像要给你：

1）self_profile：描述了我目前的技能、项目经历和性格偏好；
2）market_profile：描述了某一类岗位在市场上的共识要求（技能频率、经验要求等）。

假设：
- 我目标岗位：{{目标岗位，如 "Python 后端（杭州）" }}
- 我每周可以用于自我提升的时间：{{每周小时数，例如 "10 小时" }}
- 我的时间规划周期：{{例如 "3 个月" }}

你拿到的 self_profile 已经是**压缩视图**：
- 只包含我最重要的若干技能（含大致水平）
- 最近的几个主要项目
- 高频出现的偏好/特质

请你基于这两份画像，输出一份 Markdown 报告，结构如下：

# 针对「{{目标岗位}}」的{{周期}}行动方案

## 一、总体评估
- 技术匹配度：X%
- 项目经验匹配度：X%
- 软技能匹配度：X%

请根据 self_profile 中的技能水平、项目数量，结合 market_profile 中对应技能的频率，给出一个大致的百分比估计，并用 2~3 句话解释你的判断逻辑。

## 二、优势项
- 列出 3~5 条我相对有优势的点：
  - 指出对应的技能或项目名称
  - 说明这些内容来自 self_profile 的哪一部分

## 三、短板项（按优先级排序）
- 列出 3~7 条关键短板：
  - 短板名称（如 “Redis 实战经验不足”）
  - 市场需求情况（引用 market_profile 中对应技能的频率或要求）
  - 自身现状（引用 self_profile 中的具体描述或缺失）

请优先关注：
- 在 market_profile 中需求频率高，但在 self_profile 中几乎没有或水平较低的技能；
- 实战项目经验的缺口（例如缺少真实业务场景项目）；
- 明显影响求职的软性条件缺口（如沟通、团队协作，如果能从画像中推断）。

## 四、{{周期}}内的规划（结合每周 {{小时数}} 小时的现实约束）
- 将整个周期划分为若干阶段（如按月或按 2 周一阶段）
- 每个阶段给出：
  - 阶段主题（如 “Redis 入门 + 实战”）
  - 具体目标（如 “能给现有项目加上缓存和限流”）
  - 建议的学习/实践形式（书籍/文档/在线课程/自己动手改造现有项目），但不需要具体书名或网址
- 请注意：总任务量要符合「每周 {{小时数}} 小时」的约束，不要安排超过我实际能完成的内容。

## 五、本周可执行任务清单（Todo）
- 以本周期的首周为例，拆解出 5~10 条**具体到可以勾选的任务**：
  - 每条任务控制在 1~3 小时能完成
  - 用 Markdown 任务格式：`- [ ] ...`
  - 任务要尽量具体可操作，例如：
    - “阅读 XXX 文档的某一章节并做 3 条笔记”
    - “在现有项目中为接口 A 加上 Redis 缓存，并写一条总结笔记”
- 如果方便的话，可以在任务文本中用简短标记关联到技能，例如：
  - `- [ ] [skill:Python] 完成 XX 课程的基础部分并做 3 条笔记`

输出时：
- 使用标准 Markdown 格式。
- 所有判断，尽量引用 self_profile 和 market_profile 中的具体信息（如技能名、项目名、技能频率）。
- 不要假设我有无限时间，严格基于每周 {{小时数}} 小时来安排任务量。
- 不要输出与报告无关的解释性段落或说明。

下面是 self_profile：
{{self_profile.json}}

下面是 market_profile：
{{market_profile.json}}
```

---

这份文档就是当前「执行方案 + 改进措施」的融合增强版规格说明书，可以直接交给 Kiro，从第 6 节的 Phase 1 开始实现 TypeScript 插件。